---
layout: post
title:  "Algorithms in a Nutshell"
date:   2016-03-01 10:23:00 -0800
categories: blogging book-review computer-science
---


Blah, blah, blah. The big stuff is here. Challenging your mind with all sorts of knowledges and whatnot. When I first started computer science I came across this book [Algorithms in a Nutshell](https://ipfs.io/ipfs/QmTmMhRv2nh889JfYBWXdxSvNS6zWnh4QFo4Q2knV7Ei2B/Algorithms/Algorithms_Nutshell%20.pdf) and was very curious about the topics presented. It was much easier for me to grasp these concepts in comparison to [Introduction to Algorithms, 3rd ed.](https://www.mobilewiseguy.net/toolbox/Algorithms3rdEd.pdf), which in the begining was suggested and much of a stretch for my feeble knolwedge base to grasp at the time.
AIAN was a good concept starter for anyone who wants to learn more about algorithms, and then there are more comprehesive literatures for more advanced folks. Steven Skiena has a wonderful book, [The Algorithm Design Manual](http://sist.sysu.edu.cn/~isslxm/DSA/textbook/Skiena.-.TheAlgorithmDesignManual.pdf), that I liked so much I bought the hardcopy of it. There are many others, and I could go on and on about books, but I wanted to extend understanding of concepts in AIAN. 


### The Domains

* [Sorting Algorithms](#sorting-algorithms)
* [Searching Algorithms](#searching-algorithms)
* [Graph Algorithms](#graph-algorithms)
* [Path Finding in AI](#path-finding-in-ai)
* [Network Flow Algorithms](#network-flow-algorithms)
* [Computational Geometry](#computational-geometry)

### Sorting Algorithms

#### Insertion Sort 

Insertion sort is the 'one card at a time' sort. It is good for small data sets (< 25 elements) and things that are nearly sorted.

{% highlight java %}
void sort(int[] arr){
    for(int i = 1; i < arr.length; i++){
        insert(arr, i, arr[i]);
    }
}

void insert(int[] arr, int pos, int val){
    int i = pos - 1;
    while(i >= 0 && arr[i] > val){
        arr[i+1] = arr[i];
        i = i - 1;
        arr[i + 1] = val;
    }
}
{% endhighlight %}

#### Median Sort

{% highlight java %}
void sort(int[] arr) {
    medianSort(arr, 0, arr.length - 1 );
}

void medianSort(int [] arr, int left, int right) {
    if (left < right) {
        //find median value
        int me = findMedian(arr);   // random, scan, or last element
        int mid = (right + left)/2;
        swap(arr, mid, me);
        for(int i = left; i < mid - 1; i++) {
            if(arr[i] > arr[mid]){
                for(int j = mid + 1; j < right; j++){
                    if (arr[j] <= arr[mid]){
                        swap(arr, i, j);
                        break; // this might not break the for loop
                    }
                }
            }
        }
        medianSort(arr, left, mid - 1);
        medianSort(arr, mid, right);
    }
}
{% endhighlight %}


### Searching Algorithms

#### Sequential Search 

Also called linear search, it is your basic brute force search of iterating through each element of a container until finding the a match or exiting.

{% highlight java %}
boolean search(int[] arr, int t){
    for (int i = 0; i < arr.length; i++){
        if(arr[i] == t){
            return true;
        }
    }
    return false;
}
{% endhighlight %}

#### Binary Search

Classic Divide and Conquer method for finding an item in a collection. Input needs to be ordered completely. Output is true or false depending on contents of collection.

{% highlight java %}

boolean binarySearch(int[] arr, int t) {
    int low = 0; 
    int high = arr.length - 1;
    while(low <= high) {
        int mid = (low + high) / 2;
        if(t == arr[mid]){
            return true;
        }
        else if (t < arr[mid]) {
            high = mid - 1;
        }
        else {
            low = mid + 1;
        }
    }
    return false;
}

{% endhighlight %}

#### Hash-Based Search

Searching within a hash table for a specific value.
Best: O(1), Worst: O(n), Average: O(1)
Keywords: Array, Hash

{% highlight java %}

// loading the table
List<Integer>[] loadTable(int [] arr) {
    List<Integer>[] hashTbl = new List<>[arr.length];
    for(int i = 0; i < arr.length; i++) {
        int h = hash(arr[i]);
        if(hashTbl[h].isEmpty()) {
            hashTbl[h] = new ArrayList<>();
        }
        hashTbl[h].add(arr[i]);
    }
    return hashTbl;
}

//searching the table
boolean search(List<Integer>[] hashTbl, int t) {
    int h = hash(t);
    List<Integer> list = hashTbl[h];
    if(list.isEmpty()){
        return false;
    }
    if(list.contains(t)) {
        return true;
    }
    return false;
}
int hash(int n) {
    int h = n.hashCode();
    if (h < 0) {
        h = 0 - h;  //make positive
    }
    return h % tableSize;   //table size needs to be global
}

{% endhighlight %}

### Graph Algorithms

#### Graph Data Structure
{% highlight java %}
enum VertextColor{ White, Gray, Black};
enum EdgeType{Tree, Backward, Forward, Cross};
// for vertex u, stores information about (v,w) where edge(u,v) has the 
// designated edge weight w
public IntegerPair{
    public int u;
    public int v;
    public IntegerPair(int u, int v){
        this.u = u;
        this.v = v;
    }
}
public Graph{
    //attributes
    private boolean directed;
    private Map<Integer, List<IntegerPair>> vertexList;
    //methods
    public Graph(){}
    public Graph(int n, bool directed){}
    public Graph(int n){}
    void load(File file){}
    boolean directed(){}
    int numVerticies(){}
    boolean isEdge(int u, int v){}
    boolean isEdge(int u, int v, int weight){}
    void addEdge(int u, int v){}
    void addEdge(int u, int v, int weight){}
    boolean removeEdge(int u, int v){}
    List<IntegerPair> getEdges(int u){}

}
{% endhighlight%}

#### Depth First Search

Useful in backtracking problems and pathfinding.

{% highlight java %}
int[] d;
int[] f;
int[] pred;
VertextColor[] color;
Graph G;    //possible to complete these methods without global
int counter;
void depthFirstSearch(Graph G, int s){
    d = new int[G.numVertices()];
    f = new int[G.numVertices()];
    pred = new int[G.numVertices()];
    color = new VertextColor[G.numVertices()];
    // setup
    for (int v = 0; v < G.numVertices(); v++){
        d[v] = f[v] = pred[v] = - 1;
        color[v] = VertextColor.White;
    }
    // begin recursion
    counter = 0;
    dfsVisit(s);
    // cleanup any stragglers
    for (int v = 0; v < G.numVertices(); v++){
        if(color[v] == VertextColor.White){
            dfsVisit(v);
        }
    }
}
void dfs(int u){
    color[u] = VertextColor.Gray;
    d[u] = ++counter;
    for(IntegerPair v: G.getEdges(u)){
        if (color[v] == VertextColor.White){
            pred[v] = u;
            dfsVisit(v);
        }
    }
    color[u] = VertextColor.Black;  //visited
    f[u] = ++counter;
}

{% endhighlight %}


#### Breadth First Search

Non-backtracking graph algorithm for finding all edges connected to a node s. This search will not find disconnected sets.
Complexity: Best - O(V + E), Worst - O(V + E), Average - O(V + E)
Keywords: Graph, Array, Queue

{% highlight java %}
int [] pred;
int [] dist;
VertextColor color; 
void breadthFirstSearch(Graph G, int s) {
    pred = new int[G.numVertices()];
    dist = new int[G.numVertices()];
    color = new VertextColor[G.numVertices()];
    for (int v = 0; v < G.numVertices(); v++) {
        pred[v] = -1;
        dist[v] = Integer.MAX_VALUE;   // infinity
        color[v] = VertextColor.White;
    }
    color[s] = VertextColor.Gray;
    dist[s] = 0;
    Queue<Integer> Q = new LinkedList<>();  //empty queue
    Q.add(s);
    while(!Q.isEmpty()) {
        int u = Q.element();
        List<IntegerPairs> edges = G.getEdges(u);
        for(int v = 0; v < edges.size(); v++) {
            if (color[v] == VertextColor.White) {
                dist[v] = dist[u] + 1;
                pred[v] = u;
                color[v] = VertextColor.Gray;
                Q.add(edges.get(v));
            }
        }
        Q.remove();
        color[u] = VertextColor.Black;
    }
}

{% endhighlight %}

### Path Finding in AI

#### Game Trees

Represents each possible combination as a graph and utilizes traversals to nodes as moves. With each user move, the AI can determine the best state to transition to.

{% highlight java %}

public inteface GameState {
    boolean isDraw(){}
    boolean isWin(){}
    GameState copy(){}
    boolean equivalent(GameState other){}
}
public interface GameScore {
    int score(GameState state, Player player){}
}
public interface Player {
    int eval(GameState state){}
    void score(GameScore score){}
    List<GameMove> validMoves(GameState state){}
}
public interface GameMove {
    boolean isValid(GameState state){}
    boolean execute(GameState state){}
    boolean undo(GameState state){}
}

{% endhighlight %}

#### Search Trees
{% highlight java %}

public inteface Node {
    List<Move> validMoves(){}
    void score(int n){}
    Node copy(){}
    boolean equivalent(Node node){}
    Object key(){}
    Object storedData(Object object){}
    Object storedData(){}
}
public interface Move {
    boolean isValid(Node node){}
    boolean execute(Node node){}
    boolean undo(Node node){}
}
public inteface NodeSet {
    boolean isEmpty(){}
    int size(){}
    Node contains(Node node){}
    Node remove(Node node){}
    void insert(Node node){}
    Iterator<Node> iterator(){}
}
public Solution {
    final Node initial;
    final Node goal;
    List<Move> moves(){}
    boolean succeeded(){}
    String toString(){}
}

{% endhighlight %}

### Network Flow Algorithms

#### Maximum Flow

Computes the maximum flow between two vertices given a capacity constraint for all directed edges. This is FORD-FULKERSON algorithm.

{% highlight java %}
void compute(Graph G) {
    // use a queue
    while(!paths.isEmpty()) {
        processPath(paths(0));
    }
}
void processPath(Node n){
    //todo
}

{% endhighlight %}

### Computational Geometry

#### Convex Hull Scan

{% highlight java %}
List<Integer> convexHull(int[][] P){
    //todo
}
{% endhighlight %}
