---
layout: post
title:  "Algorithms in a Nutshell"
date:   2016-03-01 10:23:00 -0800
categories: blogging book-review computer-science
---


Blah, blah, blah. The big stuff is here. Challenging your mind with all sorts of knowledges and whatnot. When I first started computer science I came across this book [Algorithms in a Nutshell](https://ipfs.io/ipfs/QmTmMhRv2nh889JfYBWXdxSvNS6zWnh4QFo4Q2knV7Ei2B/Algorithms/Algorithms_Nutshell%20.pdf) and was very curious about the topics presented. It was much easier for me to grasp these concepts in comparison to [Introduction to Algorithms, 3rd ed.](https://www.mobilewiseguy.net/toolbox/Algorithms3rdEd.pdf), which in the begining was suggested and much of a stretch for my feeble knolwedge base to grasp at the time.
AIAN was a good concept starter for anyone who wants to learn more about algorithms, and then there are more comprehesive literatures for more advanced folks. Steven Skiena has a wonderful book, [The Algorithm Design Manual](http://sist.sysu.edu.cn/~isslxm/DSA/textbook/Skiena.-.TheAlgorithmDesignManual.pdf), that I liked so much I bought the hardcopy of it. There are many others, and I could go on and on about books, but I wanted to extend understanding of concepts in AIAN. 


### The Domains

* [Sorting Algorithms](#sorting-algorithms)
* [Searching Algorithms](#searching-algorithms)
* [Graph Algorithms](#graph-algorithms)
* [Path Finding in AI](#path-finding-in-ai)
* [Network Flow Algorithms](#network-flow-algorithms)
* [Computational Geometry](#computational-geometry)

### Sorting Algorithms

#### Insertion Sort 

Insertion sort is the 'one card at a time' sort. It is good for small data sets (< 25 elements) and things that are nearly sorted.

{% highlight java %}
void sort(int[] arr){
    for(int i = 1; i < arr.length; i++){
        insert(arr, i, arr[i]);
    }
}

void insert(int[] arr, int pos, int val){
    int i = pos - 1;
    while(i >= 0 && arr[i] > val){
        arr[i+1] = arr[i];
        i = i - 1;
        arr[i + 1] = val;
    }
}
{% endhighlight %}


### Searching Algorithms

#### Sequential Search 

Also called linear search, it is your basic brute force search of iterating through each element of a container until finding the a match or exiting.

{% highlight java %}
boolean search(int[] arr, int t){
    for (int i = 0; i < arr.length; i++){
        if(arr[i] == t){
            return true;
        }
    }
    return false;
}
{% endhighlight %}

#### Binary Search

Classic Divide and Conquer method for finding an item in a collection. Input needs to be ordered completely. Output is true or false depending on contents of collection.

{% highlight java %}

boolean binarySearch(int[] arr, int t) {
    int low = 0; 
    int high = arr.length - 1;
    while(low <= high) {
        int mid = (low + high) / 2;
        if(t == arr[mid]){
            return true;
        }
        else if (t < arr[mid]) {
            high = mid - 1;
        }
        else {
            low = mid + 1;
        }
    }
    return false;
}

{% endhighlight %}



### Graph Algorithms

#### Graph Data Structure
{% highlight java %}
enum VertextColor{ White, Gray, Black};
enum EdgeType{Tree, Backward, Forward, Cross};
// for vertex u, stores information about (v,w) where edge(u,v) has the 
// designated edge weight w
public IntegerPair{
    public int u;
    public int v;
    public IntegerPair(int u, int v){
        this.u = u;
        this.v = v;
    }
}
public Graph{
    //attributes
    private boolean directed;
    private Map<Integer, List<IntegerPair>> vertexList;
    //methods
    public Graph(){}
    public Graph(int n, bool directed){}
    public Graph(int n){}
    void load(File file){}
    boolean directed(){}
    int numVerticies(){}
    boolean isEdge(int u, int v){}
    boolean isEdge(int u, int v, int weight){}
    void addEdge(int u, int v){}
    void addEdge(int u, int v, int weight){}
    boolean removeEdge(int u, int v){}
    List<IntegerPair> getEdges(int u){}

}
{% endhighlight%}

#### Depth First Search

Useful in backtracking problems and pathfinding.

{% highlight java %}
int[] d;
int[] f;
int[] pred;
VertextColor[] color;
Graph G;    //possible to complete these methods without global
int counter;
void depthFirstSearch(Graph G, int s){
    d = new int[G.numVertices()];
    f = new int[G.numVertices()];
    pred = new int[G.numVertices()];
    color = new VertextColor[G.numVertices()];
    // setup
    for (int v = 0; v < G.numVertices(); v++){
        d[v] = f[v] = pred[v] = - 1;
        color[v] = VertextColor.White;
    }
    // begin recursion
    counter = 0;
    dfsVisit(s);
    // cleanup any stragglers
    for (int v = 0; v < G.numVertices(); v++){
        if(color[v] == VertextColor.White){
            dfsVisit(v);
        }
    }
}
void dfs(int u){
    color[u] = VertextColor.Gray;
    d[u] = ++counter;
    for(IntegerPair v: G.getEdges(u)){
        if (color[v] == VertextColor.White){
            pred[v] = u;
            dfsVisit(v);
        }
    }
    color[u] = VertextColor.Black;  //visited
    f[u] = ++counter;
}

{% endhighlight %}

### Path Finding in AI

#### Game Trees

Represents each possible combination as a graph and utilizes traversals to nodes as moves. With each user move, the AI can determine the best state to transition to.

{% highlight java %}

public inteface GameState {
    boolean isDraw(){}
    boolean isWin(){}
    GameState copy(){}
    boolean equivalent(GameState other){}
}
public interface GameScore {
    int score(GameState state, Player player){}
}
public interface Player {
    int eval(GameState state){}
    void score(GameScore score){}
    List<GameMove> validMoves(GameState state){}
}
public interface GameMove {
    boolean isValid(GameState state){}
    boolean execute(GameState state){}
    boolean undo(GameState state){}
}

{% endhighlight %}

#### Search Trees
{% highlight java %}

public inteface Node {
    List<Move> validMoves(){}
    void score(int n){}
    Node copy(){}
    boolean equivalent(Node node){}
    Object key(){}
    Object storedData(Object object){}
    Object storedData(){}
}
public interface Move {
    boolean isValid(Node node){}
    boolean execute(Node node){}
    boolean undo(Node node){}
}
public inteface NodeSet {
    boolean isEmpty(){}
    int size(){}
    Node contains(Node node){}
    Node remove(Node node){}
    void insert(Node node){}
    Iterator<Node> iterator(){}
}
public Solution {
    final Node initial;
    final Node goal;
    List<Move> moves(){}
    boolean succeeded(){}
    String toString(){}
}

{% endhighlight %}

### Network Flow Algorithms

#### Maximum Flow

Computes the maximum flow between two vertices given a capacity constraint for all directed edges. This is FORD-FULKERSON algorithm.

{% highlight java %}
void compute(Graph G) {
    // use a queue
    while(!paths.isEmpty()) {
        processPath(paths(0));
    }
}
void processPath(Node n){
    //todo
}

{% endhighlight %}

### Computational Geometry

#### Convex Hull Scan

{% highlight java %}
List<Integer> convexHull(int[][] P){
    //todo
}
{% endhighlight %}
